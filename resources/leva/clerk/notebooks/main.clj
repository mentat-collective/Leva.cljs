;; # Welcome to [Clerk](https://clerk.vision/)!

^{:nextjournal.clerk/toc true}
(ns {{top/ns}}.{{main/ns}}
    (:require [mentat.clerk-utils.show :refer [show-sci]]
              [nextjournal.clerk :as clerk]))

;; Hello! This project was generated by the [`leva/clerk`
;; template](https://leva.mentat.org/#project-template). The template comes with
;; everything you need you everything you need to

;; - Interactively develop Clerk notebooks
;; - Publish them to [GitHub Pages](https://pages.github.com/) or [Clerk's Garden](https://github.clerk.garden/)
;; - Use a [custom ClojureScript build](https://clerk-utils.mentat.org/#custom-clojurescript-builds) in both modes

;; Some good next steps:

;; - Visit this project's README.md for guides on how to proceed.
;; - Read the [`Leva.cljs` documentation notebook](https://leva.mentat.org)
;; - Read the [Book of Clerk](https://book.clerk.vision/)
;; - Visit the [Awesome-Clerk](https://github.com/mentat-collective/awesome-clerk) list for ideas
;; - Delete anything in this notebook you feel like you don't need.

;; ## Clerk Environment Basics
;;
;; Here's a basic use of Clerk. This is a function:

(defn hello [s]
  (str "Hello, " s "!"))

;; If we call this function, Clerk will render the form and its output:

(hello "Clerk")

;; - The form `(hello "Clerk")` executes in the JVM.
;; - The resulting string "Hello, Clerk!" is serialized over a WebSocket to the
;;   browser, where Clerk's ClojureScript side renders it using a
;;   pre-registered "viewer".
;; - These viewers are written in code evaluated using the [Small Clojure
;;   Interpreter](https://github.com/babashka/sci), or "SCI".

;; Clerk comes with [many viewers](https://book.clerk.vision/#viewers), and
;; gives us the ability to [write _new_
;; viewers](https://book.clerk.vision/#writing-viewers) using a default SCI
;; environment that Clerk makes available to us.

;; ## Leva Quickstart

;; The following snippet implements the example from
;; the ["Quickstart"](https://leva.mentat.org/#quickstart) section of
;; the [`Leva.cljs` docs notebook](https://leva.mentat.org/#quickstart)

;; Declare some state that you'd like to control with a GUI. Each entry's key
;; becomes its label, and Leva infers the correct input from the value's type.

(show-sci
 (defonce !synced
   (reagent.core/atom
    {:number 10
     :color {:r 10 :g 12 :b 4}
     :string "Hi!"
     :point {:x 1 :y 1}})))

;; Pass the atom to the `leva.core/Controls` component via the `:atom` key to
;; add its entries to the Leva panel hovering on the right, and bidirectionally
;; bind its state to the interactive state in the panel:

(show-sci
 [leva.core/Controls
  {:folder {:name "Quickstart"}
   :atom !synced}])

;; Drag the control panel around to a more convenient place on the page, then
;; play around with the UI elements and watch the state change:

(show-sci
 [v/inspect @!synced])
